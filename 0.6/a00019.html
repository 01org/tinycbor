<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>TinyCBOR  API: Parsing CBOR streams</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TinyCBOR  API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Parsing CBOR streams</div>  </div>
</div><!--header-->
<div class="contents">

<p>Group of functions used to parse CBOR streams.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html">CborValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type contains one value parsed from the CBOR stream.  <a href="a00002.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac7df91cad1cba43d5d0103284fc390fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gac7df91cad1cba43d5d0103284fc390fc">CborValidationFlags</a> </td></tr>
<tr class="memdesc:gac7df91cad1cba43d5d0103284fc390fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CborValidationFlags enum contains flags that control the validation of a CBOR stream.  <a href="a00019.html#gac7df91cad1cba43d5d0103284fc390fc">More...</a><br/></td></tr>
<tr class="separator:gac7df91cad1cba43d5d0103284fc390fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadb356bb705f2d8239f03b36081a43b4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gadb356bb705f2d8239f03b36081a43b4f">cbor_parser_init</a> (const uint8_t *buffer, size_t size, int flags, CborParser *parser, <a class="el" href="a00002.html">CborValue</a> *it)</td></tr>
<tr class="memdesc:gadb356bb705f2d8239f03b36081a43b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the CBOR parser for parsing <em>size</em> bytes beginning at <em>buffer</em>.  <a href="#gadb356bb705f2d8239f03b36081a43b4f">More...</a><br/></td></tr>
<tr class="separator:gadb356bb705f2d8239f03b36081a43b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19b60bc2cff3d3ffcc81adbcad09fd58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga19b60bc2cff3d3ffcc81adbcad09fd58">cbor_value_validate_basic</a> (const <a class="el" href="a00002.html">CborValue</a> *it)</td></tr>
<tr class="memdesc:ga19b60bc2cff3d3ffcc81adbcad09fd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a basic validation of the CBOR stream pointed by <em>it</em> and returns the error it found.  <a href="#ga19b60bc2cff3d3ffcc81adbcad09fd58">More...</a><br/></td></tr>
<tr class="separator:ga19b60bc2cff3d3ffcc81adbcad09fd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0701f791608589ddfff0bdb8acee7b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gac0701f791608589ddfff0bdb8acee7b4">cbor_value_advance_fixed</a> (<a class="el" href="a00002.html">CborValue</a> *it)</td></tr>
<tr class="memdesc:gac0701f791608589ddfff0bdb8acee7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the CBOR value <em>it</em> by one fixed-size position.  <a href="#gac0701f791608589ddfff0bdb8acee7b4">More...</a><br/></td></tr>
<tr class="separator:gac0701f791608589ddfff0bdb8acee7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ede5aacd59f04437c24ef8ca2f449a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gae2ede5aacd59f04437c24ef8ca2f449a">cbor_value_advance</a> (<a class="el" href="a00002.html">CborValue</a> *it)</td></tr>
<tr class="memdesc:gae2ede5aacd59f04437c24ef8ca2f449a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the CBOR value <em>it</em> by one element, skipping over containers.  <a href="#gae2ede5aacd59f04437c24ef8ca2f449a">More...</a><br/></td></tr>
<tr class="separator:gae2ede5aacd59f04437c24ef8ca2f449a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b805f0f440905a7ba4f93b3569bb97b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga2b805f0f440905a7ba4f93b3569bb97b">cbor_value_skip_tag</a> (<a class="el" href="a00002.html">CborValue</a> *it)</td></tr>
<tr class="memdesc:ga2b805f0f440905a7ba4f93b3569bb97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the CBOR value <em>it</em> until it no longer points to a tag.  <a href="#ga2b805f0f440905a7ba4f93b3569bb97b">More...</a><br/></td></tr>
<tr class="separator:ga2b805f0f440905a7ba4f93b3569bb97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c8a61e484973272f34b00cfbef9ddfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga0c8a61e484973272f34b00cfbef9ddfd">cbor_value_enter_container</a> (const <a class="el" href="a00002.html">CborValue</a> *it, <a class="el" href="a00002.html">CborValue</a> *recursed)</td></tr>
<tr class="memdesc:ga0c8a61e484973272f34b00cfbef9ddfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="a00002.html" title="This type contains one value parsed from the CBOR stream. ">CborValue</a> iterator pointing to the first element of the container represented by <em>it</em> and saves it in <em>recursed</em>.  <a href="#ga0c8a61e484973272f34b00cfbef9ddfd">More...</a><br/></td></tr>
<tr class="separator:ga0c8a61e484973272f34b00cfbef9ddfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e02f0b62bc864fe8cf290988936e15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga51e02f0b62bc864fe8cf290988936e15">cbor_value_leave_container</a> (<a class="el" href="a00002.html">CborValue</a> *it, const <a class="el" href="a00002.html">CborValue</a> *recursed)</td></tr>
<tr class="memdesc:ga51e02f0b62bc864fe8cf290988936e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <em>it</em> to point to the next element after the container.  <a href="#ga51e02f0b62bc864fe8cf290988936e15">More...</a><br/></td></tr>
<tr class="separator:ga51e02f0b62bc864fe8cf290988936e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bd9f8ab2b61aaeb31fd9b724622f0df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga5bd9f8ab2b61aaeb31fd9b724622f0df">cbor_value_get_int64_checked</a> (const <a class="el" href="a00002.html">CborValue</a> *value, int64_t *result)</td></tr>
<tr class="memdesc:ga5bd9f8ab2b61aaeb31fd9b724622f0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the CBOR integer value that <em>value</em> points to and stores it in <em>result</em>.  <a href="#ga5bd9f8ab2b61aaeb31fd9b724622f0df">More...</a><br/></td></tr>
<tr class="separator:ga5bd9f8ab2b61aaeb31fd9b724622f0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b7aba18f57c255e744b874645ac9be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gaf9b7aba18f57c255e744b874645ac9be">cbor_value_get_int_checked</a> (const <a class="el" href="a00002.html">CborValue</a> *value, int *result)</td></tr>
<tr class="memdesc:gaf9b7aba18f57c255e744b874645ac9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the CBOR integer value that <em>value</em> points to and stores it in <em>result</em>.  <a href="#gaf9b7aba18f57c255e744b874645ac9be">More...</a><br/></td></tr>
<tr class="separator:gaf9b7aba18f57c255e744b874645ac9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b2dd803244946b15603e09ce147044"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gad5b2dd803244946b15603e09ce147044">cbor_value_calculate_string_length</a> (const <a class="el" href="a00002.html">CborValue</a> *value, size_t *len)</td></tr>
<tr class="memdesc:gad5b2dd803244946b15603e09ce147044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the length of the byte or text string that <em>value</em> points to and stores it in <em>len</em>.  <a href="#gad5b2dd803244946b15603e09ce147044">More...</a><br/></td></tr>
<tr class="separator:gad5b2dd803244946b15603e09ce147044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8f08df74d65c8454528824a667550ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gac8f08df74d65c8454528824a667550ec">cbor_value_text_string_equals</a> (const <a class="el" href="a00002.html">CborValue</a> *value, const char *string, bool *result)</td></tr>
<tr class="memdesc:gac8f08df74d65c8454528824a667550ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the entry <em>value</em> with the string <em>string</em> and store the result in <em>result</em>.  <a href="#gac8f08df74d65c8454528824a667550ec">More...</a><br/></td></tr>
<tr class="separator:gac8f08df74d65c8454528824a667550ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf145f4513ce734265d0128429cc4d5bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gaf145f4513ce734265d0128429cc4d5bd">cbor_value_map_find_value</a> (const <a class="el" href="a00002.html">CborValue</a> *map, const char *string, <a class="el" href="a00002.html">CborValue</a> *element)</td></tr>
<tr class="memdesc:gaf145f4513ce734265d0128429cc4d5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find the value in map <em>map</em> that corresponds to the text string entry <em>string</em>.  <a href="#gaf145f4513ce734265d0128429cc4d5bd">More...</a><br/></td></tr>
<tr class="separator:gaf145f4513ce734265d0128429cc4d5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7636f480757b302845ee38227f15cef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga7636f480757b302845ee38227f15cef1">cbor_value_validate</a> (const <a class="el" href="a00002.html">CborValue</a> *it, int flags)</td></tr>
<tr class="memdesc:ga7636f480757b302845ee38227f15cef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a full validation controlled by the <em>flags</em> options of the CBOR stream pointed by <em>it</em> and returns the error it found.  <a href="#ga7636f480757b302845ee38227f15cef1">More...</a><br/></td></tr>
<tr class="separator:ga7636f480757b302845ee38227f15cef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49bd2a99edcceb72962eedc7584cd19c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga49bd2a99edcceb72962eedc7584cd19c">cbor_value_at_end</a> (const <a class="el" href="a00002.html">CborValue</a> *it)</td></tr>
<tr class="memdesc:ga49bd2a99edcceb72962eedc7584cd19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <em>it</em> has reached the end of the iteration, usually when advancing after the last item in an array or map.  <a href="#ga49bd2a99edcceb72962eedc7584cd19c">More...</a><br/></td></tr>
<tr class="separator:ga49bd2a99edcceb72962eedc7584cd19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06b1da795150786eb43ee83d65cd17d7"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga06b1da795150786eb43ee83d65cd17d7">cbor_value_get_next_byte</a> (const <a class="el" href="a00002.html">CborValue</a> *it)</td></tr>
<tr class="memdesc:ga06b1da795150786eb43ee83d65cd17d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the next byte that would be decoded if this <a class="el" href="a00002.html" title="This type contains one value parsed from the CBOR stream. ">CborValue</a> object were advanced.  <a href="#ga06b1da795150786eb43ee83d65cd17d7">More...</a><br/></td></tr>
<tr class="separator:ga06b1da795150786eb43ee83d65cd17d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8bf13b3880863cf5c8a0bddf52426e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6">cbor_value_is_valid</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:gae8bf13b3880863cf5c8a0bddf52426e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>it</em> contains a valid value.  <a href="#gae8bf13b3880863cf5c8a0bddf52426e6">More...</a><br/></td></tr>
<tr class="separator:gae8bf13b3880863cf5c8a0bddf52426e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga283d20b9bd9787647841dd245d486b1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga283d20b9bd9787647841dd245d486b1d">cbor_value_is_tag</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:ga283d20b9bd9787647841dd245d486b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR tag.  <a href="#ga283d20b9bd9787647841dd245d486b1d">More...</a><br/></td></tr>
<tr class="separator:ga283d20b9bd9787647841dd245d486b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee8cd4c95df1d788f5ef8fee6ac101a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga4ee8cd4c95df1d788f5ef8fee6ac101a">cbor_value_get_tag</a> (const <a class="el" href="a00002.html">CborValue</a> *value, <a class="el" href="a00017.html#ga46c29d9d57408740dc269d6125d37d26">CborTag</a> *result)</td></tr>
<tr class="memdesc:ga4ee8cd4c95df1d788f5ef8fee6ac101a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the CBOR tag value that <em>value</em> points to and stores it in <em>result</em>.  <a href="#ga4ee8cd4c95df1d788f5ef8fee6ac101a">More...</a><br/></td></tr>
<tr class="separator:ga4ee8cd4c95df1d788f5ef8fee6ac101a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3da16a547bcb54d3ad2ca70cf0f4341"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf3da16a547bcb54d3ad2ca70cf0f4341"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gaf3da16a547bcb54d3ad2ca70cf0f4341">cbor_value_is_container</a> (const <a class="el" href="a00002.html">CborValue</a> *it)</td></tr>
<tr class="memdesc:gaf3da16a547bcb54d3ad2ca70cf0f4341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <em>it</em> value is a container and requires recursion in order to decode (maps and arrays), false otherwise. <br/></td></tr>
<tr class="separator:gaf3da16a547bcb54d3ad2ca70cf0f4341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49bb974313534553ccafb28e5eba46d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga38f51ceba8bc8a9b1cf7dd31e3f9c178">CborType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:ga49bb974313534553ccafb28e5eba46d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the CBOR value that the iterator <em>value</em> points to.  <a href="#ga49bb974313534553ccafb28e5eba46d5">More...</a><br/></td></tr>
<tr class="separator:ga49bb974313534553ccafb28e5eba46d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11f38fada70d371257f7b51f311e8826"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga11f38fada70d371257f7b51f311e8826">cbor_value_is_null</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:ga11f38fada70d371257f7b51f311e8826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR null type.  <a href="#ga11f38fada70d371257f7b51f311e8826">More...</a><br/></td></tr>
<tr class="separator:ga11f38fada70d371257f7b51f311e8826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1079ce3272f905c3d4a20821507be6f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga1079ce3272f905c3d4a20821507be6f6">cbor_value_is_undefined</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:ga1079ce3272f905c3d4a20821507be6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR undefined type.  <a href="#ga1079ce3272f905c3d4a20821507be6f6">More...</a><br/></td></tr>
<tr class="separator:ga1079ce3272f905c3d4a20821507be6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f85ec6748006a36c237a79d6f223b29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga0f85ec6748006a36c237a79d6f223b29">cbor_value_is_boolean</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:ga0f85ec6748006a36c237a79d6f223b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR boolean type (true or false).  <a href="#ga0f85ec6748006a36c237a79d6f223b29">More...</a><br/></td></tr>
<tr class="separator:ga0f85ec6748006a36c237a79d6f223b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade7bfd61f35e448b1119d9bcfce234c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gade7bfd61f35e448b1119d9bcfce234c0">cbor_value_get_boolean</a> (const <a class="el" href="a00002.html">CborValue</a> *value, bool *result)</td></tr>
<tr class="memdesc:gade7bfd61f35e448b1119d9bcfce234c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the boolean value that <em>value</em> points to and stores it in <em>result</em>.  <a href="#gade7bfd61f35e448b1119d9bcfce234c0">More...</a><br/></td></tr>
<tr class="separator:gade7bfd61f35e448b1119d9bcfce234c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae1a1b893975549d5fa74452ba4b79e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gaae1a1b893975549d5fa74452ba4b79e8">cbor_value_is_simple_type</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:gaae1a1b893975549d5fa74452ba4b79e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR Simple Type type (other than true, false, null and undefined).  <a href="#gaae1a1b893975549d5fa74452ba4b79e8">More...</a><br/></td></tr>
<tr class="separator:gaae1a1b893975549d5fa74452ba4b79e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga033d3d2c9570501cf9dce099fe98e863"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga033d3d2c9570501cf9dce099fe98e863">cbor_value_get_simple_type</a> (const <a class="el" href="a00002.html">CborValue</a> *value, uint8_t *result)</td></tr>
<tr class="memdesc:ga033d3d2c9570501cf9dce099fe98e863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the CBOR Simple Type value that <em>value</em> points to and stores it in <em>result</em>.  <a href="#ga033d3d2c9570501cf9dce099fe98e863">More...</a><br/></td></tr>
<tr class="separator:ga033d3d2c9570501cf9dce099fe98e863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ea2ca067d876ca95251005f4ad696b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga3ea2ca067d876ca95251005f4ad696b0">cbor_value_is_integer</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:ga3ea2ca067d876ca95251005f4ad696b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR integer type.  <a href="#ga3ea2ca067d876ca95251005f4ad696b0">More...</a><br/></td></tr>
<tr class="separator:ga3ea2ca067d876ca95251005f4ad696b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6aaf9010ea974034fe62b4670e44235"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gac6aaf9010ea974034fe62b4670e44235">cbor_value_is_unsigned_integer</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:gac6aaf9010ea974034fe62b4670e44235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR unsigned integer type (positive values or zero).  <a href="#gac6aaf9010ea974034fe62b4670e44235">More...</a><br/></td></tr>
<tr class="separator:gac6aaf9010ea974034fe62b4670e44235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaecdd62ea0656b7c4b367b19648ac79b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gaaecdd62ea0656b7c4b367b19648ac79b">cbor_value_is_negative_integer</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:gaaecdd62ea0656b7c4b367b19648ac79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR negative integer type.  <a href="#gaaecdd62ea0656b7c4b367b19648ac79b">More...</a><br/></td></tr>
<tr class="separator:gaaecdd62ea0656b7c4b367b19648ac79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf95f402facf8436989b830f1dd4b06a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gabf95f402facf8436989b830f1dd4b06a">cbor_value_get_int</a> (const <a class="el" href="a00002.html">CborValue</a> *value, int *result)</td></tr>
<tr class="memdesc:gabf95f402facf8436989b830f1dd4b06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the CBOR integer value that <em>value</em> points to and stores it in <em>result</em>.  <a href="#gabf95f402facf8436989b830f1dd4b06a">More...</a><br/></td></tr>
<tr class="separator:gabf95f402facf8436989b830f1dd4b06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae16139e4a8857033b908dad98ddb2ac3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gae16139e4a8857033b908dad98ddb2ac3">cbor_value_get_int64</a> (const <a class="el" href="a00002.html">CborValue</a> *value, int64_t *result)</td></tr>
<tr class="memdesc:gae16139e4a8857033b908dad98ddb2ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the CBOR integer value that <em>value</em> points to and stores it in <em>result</em>.  <a href="#gae16139e4a8857033b908dad98ddb2ac3">More...</a><br/></td></tr>
<tr class="separator:gae16139e4a8857033b908dad98ddb2ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c30532c395047b62ccc7c7eeb3a51b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gab4c30532c395047b62ccc7c7eeb3a51b">cbor_value_get_uint64</a> (const <a class="el" href="a00002.html">CborValue</a> *value, uint64_t *result)</td></tr>
<tr class="memdesc:gab4c30532c395047b62ccc7c7eeb3a51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the CBOR integer value that <em>value</em> points to and stores it in <em>result</em>.  <a href="#gab4c30532c395047b62ccc7c7eeb3a51b">More...</a><br/></td></tr>
<tr class="separator:gab4c30532c395047b62ccc7c7eeb3a51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30c4dc9fb923feac58d962b02aeecd41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga30c4dc9fb923feac58d962b02aeecd41">cbor_value_get_raw_integer</a> (const <a class="el" href="a00002.html">CborValue</a> *value, uint64_t *result)</td></tr>
<tr class="memdesc:ga30c4dc9fb923feac58d962b02aeecd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the CBOR integer value that <em>value</em> points to and stores it in <em>result</em>.  <a href="#ga30c4dc9fb923feac58d962b02aeecd41">More...</a><br/></td></tr>
<tr class="separator:ga30c4dc9fb923feac58d962b02aeecd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0422ed961d973d190a19e12a3fe2390f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga0422ed961d973d190a19e12a3fe2390f">cbor_value_is_length_known</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:ga0422ed961d973d190a19e12a3fe2390f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the length of this type is known without calculation.  <a href="#ga0422ed961d973d190a19e12a3fe2390f">More...</a><br/></td></tr>
<tr class="separator:ga0422ed961d973d190a19e12a3fe2390f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed463f5bf4b69d7aec41e6aca9c637ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gaed463f5bf4b69d7aec41e6aca9c637ad">cbor_value_is_text_string</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:gaed463f5bf4b69d7aec41e6aca9c637ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR text string.  <a href="#gaed463f5bf4b69d7aec41e6aca9c637ad">More...</a><br/></td></tr>
<tr class="separator:gaed463f5bf4b69d7aec41e6aca9c637ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad864d46aa7cfa3d57813da2b242380b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gad864d46aa7cfa3d57813da2b242380b4">cbor_value_is_byte_string</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:gad864d46aa7cfa3d57813da2b242380b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR text string.  <a href="#gad864d46aa7cfa3d57813da2b242380b4">More...</a><br/></td></tr>
<tr class="separator:gad864d46aa7cfa3d57813da2b242380b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf39519cfc9a8fb64a787348af835569c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gaf39519cfc9a8fb64a787348af835569c">cbor_value_get_string_length</a> (const <a class="el" href="a00002.html">CborValue</a> *value, size_t *length)</td></tr>
<tr class="memdesc:gaf39519cfc9a8fb64a787348af835569c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the length of the byte or text string that <em>value</em> points to and stores it in <em>result</em>.  <a href="#gaf39519cfc9a8fb64a787348af835569c">More...</a><br/></td></tr>
<tr class="separator:gaf39519cfc9a8fb64a787348af835569c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb1070d99c7094657271ef914b40a91b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gacb1070d99c7094657271ef914b40a91b">cbor_value_get_text_string_chunk</a> (const <a class="el" href="a00002.html">CborValue</a> *value, const char **bufferptr, size_t *len, <a class="el" href="a00002.html">CborValue</a> *next)</td></tr>
<tr class="memdesc:gacb1070d99c7094657271ef914b40a91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts one text string chunk pointed to by <em>value</em> and stores a pointer to the data in <em>buffer</em> and the size in <em>len</em>, which must not be null.  <a href="#gacb1070d99c7094657271ef914b40a91b">More...</a><br/></td></tr>
<tr class="separator:gacb1070d99c7094657271ef914b40a91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02ec0b5c8346f407cf5def566ddcf5ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga02ec0b5c8346f407cf5def566ddcf5ae">cbor_value_copy_text_string</a> (const <a class="el" href="a00002.html">CborValue</a> *value, char *buffer, size_t *buflen, <a class="el" href="a00002.html">CborValue</a> *next)</td></tr>
<tr class="memdesc:ga02ec0b5c8346f407cf5def566ddcf5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the string pointed by <em>value</em> into the buffer provided at <em>buffer</em> of <em>buflen</em> bytes.  <a href="#ga02ec0b5c8346f407cf5def566ddcf5ae">More...</a><br/></td></tr>
<tr class="separator:ga02ec0b5c8346f407cf5def566ddcf5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5204b942fd5e6e1d8064262f3ce96b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gac5204b942fd5e6e1d8064262f3ce96b3">cbor_value_copy_byte_string</a> (const <a class="el" href="a00002.html">CborValue</a> *value, uint8_t *buffer, size_t *buflen, <a class="el" href="a00002.html">CborValue</a> *next)</td></tr>
<tr class="memdesc:gac5204b942fd5e6e1d8064262f3ce96b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the string pointed by <em>value</em> into the buffer provided at <em>buffer</em> of <em>buflen</em> bytes.  <a href="#gac5204b942fd5e6e1d8064262f3ce96b3">More...</a><br/></td></tr>
<tr class="separator:gac5204b942fd5e6e1d8064262f3ce96b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf427a0fdeb50f7a94d3c3620dd36161"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gadf427a0fdeb50f7a94d3c3620dd36161">cbor_value_is_array</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:gadf427a0fdeb50f7a94d3c3620dd36161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR array.  <a href="#gadf427a0fdeb50f7a94d3c3620dd36161">More...</a><br/></td></tr>
<tr class="separator:gadf427a0fdeb50f7a94d3c3620dd36161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3dec7120c8ce4326aea96c6eec6090c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gae3dec7120c8ce4326aea96c6eec6090c">cbor_value_get_array_length</a> (const <a class="el" href="a00002.html">CborValue</a> *value, size_t *length)</td></tr>
<tr class="memdesc:gae3dec7120c8ce4326aea96c6eec6090c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the length of the CBOR array that <em>value</em> points to and stores it in <em>result</em>.  <a href="#gae3dec7120c8ce4326aea96c6eec6090c">More...</a><br/></td></tr>
<tr class="separator:gae3dec7120c8ce4326aea96c6eec6090c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b34d5f429a4c77f451391c4f7dff497"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga1b34d5f429a4c77f451391c4f7dff497">cbor_value_is_map</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:ga1b34d5f429a4c77f451391c4f7dff497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR map.  <a href="#ga1b34d5f429a4c77f451391c4f7dff497">More...</a><br/></td></tr>
<tr class="separator:ga1b34d5f429a4c77f451391c4f7dff497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82740107f90881f83e7fb44ed74674b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gad82740107f90881f83e7fb44ed74674b">cbor_value_get_map_length</a> (const <a class="el" href="a00002.html">CborValue</a> *value, size_t *length)</td></tr>
<tr class="memdesc:gad82740107f90881f83e7fb44ed74674b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the length of the CBOR map that <em>value</em> points to and stores it in <em>result</em>.  <a href="#gad82740107f90881f83e7fb44ed74674b">More...</a><br/></td></tr>
<tr class="separator:gad82740107f90881f83e7fb44ed74674b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda7173c376b4789887db1717ef3f1b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gafda7173c376b4789887db1717ef3f1b8">cbor_value_is_float</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:gafda7173c376b4789887db1717ef3f1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR single-precision floating point (32-bit).  <a href="#gafda7173c376b4789887db1717ef3f1b8">More...</a><br/></td></tr>
<tr class="separator:gafda7173c376b4789887db1717ef3f1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcb81c2eeff3cc6dab0f2da699bb564b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gafcb81c2eeff3cc6dab0f2da699bb564b">cbor_value_get_float</a> (const <a class="el" href="a00002.html">CborValue</a> *value, float *result)</td></tr>
<tr class="memdesc:gafcb81c2eeff3cc6dab0f2da699bb564b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the CBOR single-precision floating point (32-bit) value that <em>value</em> points to and stores it in <em>result</em>.  <a href="#gafcb81c2eeff3cc6dab0f2da699bb564b">More...</a><br/></td></tr>
<tr class="separator:gafcb81c2eeff3cc6dab0f2da699bb564b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga911e93729874ae5a2b4560c5bfe83ec3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga911e93729874ae5a2b4560c5bfe83ec3">cbor_value_is_double</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:ga911e93729874ae5a2b4560c5bfe83ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR double-precision floating point (64-bit).  <a href="#ga911e93729874ae5a2b4560c5bfe83ec3">More...</a><br/></td></tr>
<tr class="separator:ga911e93729874ae5a2b4560c5bfe83ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab44b87547a7c5a028479354d2f66c46c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#gab44b87547a7c5a028479354d2f66c46c">cbor_value_is_half_float</a> (const <a class="el" href="a00002.html">CborValue</a> *value)</td></tr>
<tr class="memdesc:gab44b87547a7c5a028479354d2f66c46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the iterator <em>value</em> is valid and points to a CBOR single-precision floating point (16-bit).  <a href="#gab44b87547a7c5a028479354d2f66c46c">More...</a><br/></td></tr>
<tr class="separator:gab44b87547a7c5a028479354d2f66c46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga566e51dcf54db8eb43ec19e8d31b8c6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ga566e51dcf54db8eb43ec19e8d31b8c6f">cbor_value_get_half_float</a> (const <a class="el" href="a00002.html">CborValue</a> *value, void *result)</td></tr>
<tr class="memdesc:ga566e51dcf54db8eb43ec19e8d31b8c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the CBOR half-precision floating point (16-bit) value that <em>value</em> points to and stores it in <em>result</em>.  <a href="#ga566e51dcf54db8eb43ec19e8d31b8c6f">More...</a><br/></td></tr>
<tr class="separator:ga566e51dcf54db8eb43ec19e8d31b8c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Group of functions used to parse CBOR streams. </p>
<p>TinyCBOR provides functions for pull-based stream parsing of a CBOR-encoded payload. The main data type for the parsing is a <a class="el" href="a00002.html" title="This type contains one value parsed from the CBOR stream. ">CborValue</a>, which behaves like an iterator and can be used to extract the encoded data. It is first initialized with a call to <a class="el" href="a00019.html#gadb356bb705f2d8239f03b36081a43b4f" title="Initializes the CBOR parser for parsing size bytes beginning at buffer. ">cbor_parser_init()</a> and is usually used to extract exactly one item, most often an array or map.</p>
<p>Nested <a class="el" href="a00002.html" title="This type contains one value parsed from the CBOR stream. ">CborValue</a> objects can be parsed using <a class="el" href="a00019.html#ga0c8a61e484973272f34b00cfbef9ddfd" title="Creates a CborValue iterator pointing to the first element of the container represented by it and sav...">cbor_value_enter_container()</a>. Each call to <a class="el" href="a00019.html#ga0c8a61e484973272f34b00cfbef9ddfd" title="Creates a CborValue iterator pointing to the first element of the container represented by it and sav...">cbor_value_enter_container()</a> must be matched by a call to <a class="el" href="a00019.html#ga51e02f0b62bc864fe8cf290988936e15" title="Updates it to point to the next element after the container. ">cbor_value_leave_container()</a>, with the exact same parameters.</p>
<p>The example below initializes a CborParser object, begins the parsing with a <a class="el" href="a00002.html" title="This type contains one value parsed from the CBOR stream. ">CborValue</a> and decodes a single integer:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> extract_int(<span class="keyword">const</span> uint8_t *buffer, <span class="keywordtype">size_t</span> len)</div>
<div class="line">{</div>
<div class="line">    CborParser parser;</div>
<div class="line">    <a class="code" href="a00002.html">CborValue</a> value;</div>
<div class="line">    <span class="keywordtype">int</span> result;</div>
<div class="line">    <a class="code" href="a00019.html#gadb356bb705f2d8239f03b36081a43b4f">cbor_parser_init</a>(buffer, len, 0, &amp;buffer, &amp;value);</div>
<div class="line">    <a class="code" href="a00019.html#gabf95f402facf8436989b830f1dd4b06a">cbor_value_get_int</a>(&amp;value, &amp;result);</div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The code above does no error checking, which means it assumes the data comes from a source trusted to send one properly-encoded integer. The following example does the exact same operation, but includes error parsing and returns 0 on parsing failure:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> extract_int(<span class="keyword">const</span> uint8_t *buffer, <span class="keywordtype">size_t</span> len)</div>
<div class="line">{</div>
<div class="line">    CborParser parser;</div>
<div class="line">    <a class="code" href="a00002.html">CborValue</a> value;</div>
<div class="line">    <span class="keywordtype">int</span> result;</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="a00019.html#gadb356bb705f2d8239f03b36081a43b4f">cbor_parser_init</a>(buffer, len, 0, &amp;buffer, &amp;value) != CborNoError)</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="a00019.html#ga3ea2ca067d876ca95251005f4ad696b0">cbor_value_is_integer</a>(&amp;value) ||</div>
<div class="line">            <a class="code" href="a00019.html#gabf95f402facf8436989b830f1dd4b06a">cbor_value_get_int</a>(&amp;value, &amp;result) != CborNoError)</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note, in the example above, that one can't distinguish a parsing failure from an encoded value of zero. Reporting a parsing error is left as an exercise to the reader.</p>
<p>The code above does not execute a range-check either: it is possible that the value decoded from the CBOR stream encodes a number larger than what can be represented in a variable of type <code></code>{int}. If detecting that case is important, the code should call <a class="el" href="a00019.html#gaf9b7aba18f57c255e744b874645ac9be" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_int_checked()</a> instead.</p>
<h3 class="groupheader">Memory and parsing constraints</h3>
<p>TinyCBOR is designed to run with little memory and with minimal overhead. Except where otherwise noted, the parser functions always run on constant time (O(1)), do not recurse and never allocate memory (thus, stack usage is bounded and is O(1)).</p>
<h3 class="groupheader">Error handling and preconditions</h3>
<p>All functions operating on a <a class="el" href="a00002.html" title="This type contains one value parsed from the CBOR stream. ">CborValue</a> return a CborError condition, with CborNoError standing for the normal situation in which no parsing error occurred. All functions may return parsing errors in case the stream cannot be decoded properly, be it due to corrupted data or due to reaching the end of the input buffer.</p>
<p>Error conditions must not be ignored. All decoder functions have undefined behavior if called after an error has been reported, and may crash.</p>
<p>Some functions are also documented to have preconditions, like <a class="el" href="a00019.html#gabf95f402facf8436989b830f1dd4b06a" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_int()</a> requiring that the input be an integral value. Violation of preconditions also results in undefined behavior and the program may crash. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gac7df91cad1cba43d5d0103284fc390fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00019.html#gac7df91cad1cba43d5d0103284fc390fc">CborValidationFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CborValidationFlags enum contains flags that control the validation of a CBOR stream. </p>
<ul>
<li><code>CborValidateBasic</code> Validates only the syntax correctedness of the stream. </li>
<li><code>CborValidateCanonical</code> Validates that the stream is in canonical format, according to RFC 7049 section 3.9. </li>
<li><code>CborValidateStrictMode</code> Performs strict validation, according to RFC 7049 section 3.10. </li>
<li><code>CborValidateStrictest</code> Attempt to perform the strictest validation we know of.</li>
</ul>
<ul>
<li><code>CborValidateShortestIntegrals</code> (Canonical) Validate that integral numbers and lengths are enconded in their shortest form possible. </li>
<li><code>CborValidateShortestFloatingPoint</code> (Canonical) Validate that floating-point numbers are encoded in their shortest form possible. </li>
<li><code>CborValidateShortestNumbers</code> (Canonical) Validate both integrals and floating-point numbers are in their shortest form possible. </li>
<li><code>CborValidateNoIndeterminateLength</code> (Canonical) Validate that no string, array or map uses indeterminate length encoding. </li>
<li><code>CborValidateMapIsSorted</code> (Canonical &amp; Strict mode) Validate that map keys appear in sorted order. </li>
<li><code>CborValidateMapKeysAreUnique</code> (Strict mode) Validate that map keys are unique. </li>
<li><code>CborValidateTagUse</code> (Strict mode) Validate that known tags are used with the correct types. This does not validate that the content of those types is syntactically correct. </li>
<li><code>CborValidateUtf8</code> (Strict mode) Validate that text strings are appropriately encoded in UTF-8. </li>
<li><code>CborValidateMapKeysAreString</code> Validate that all map keys are text strings. </li>
<li><code>CborValidateNoUndefined</code> Validate that no elements of type "undefined" are present. </li>
<li><code>CborValidateNoTags</code> Validate that no tags are used. </li>
<li><code>CborValidateFiniteFloatingPoint</code> Validate that all floating point numbers are finite (no NaN or infinities are allowed). </li>
<li><code>CborValidateCompleteData</code> Validate that the stream is complete and there is no more data in the buffer. </li>
<li><code>CborValidateNoUnknownSimpleTypesSA</code> Validate that all Standards Action simple types are registered with IANA. </li>
<li><code>CborValidateNoUnknownSimpleTypes</code> Validate that all simple types used are registered with IANA. </li>
<li><code>CborValidateNoUnknownTagsSA</code> Validate that all Standard Actions tags are registered with IANA. </li>
<li><code>CborValidateNoUnknownTagsSR</code> Validate that all Standard Actions and Specification Required tags are registered with IANA (see below for limitations). </li>
<li><code>CborValidateNoUnkonwnTags</code> Validate that all tags are registered with IANA (see below for limitations).</li>
</ul>
<dl class="section user"><dt>Simple type registry</dt><dd>The CBOR specification requires that registration for use of the first 19 simple types must be done by way of Standards Action. The rest of the simple types only require a specification. The official list can be obtained from <a href="https://www.iana.org/assignments/cbor-simple-values/cbor-simple-values.xhtml">https://www.iana.org/assignments/cbor-simple-values/cbor-simple-values.xhtml</a>.</dd></dl>
<dl class="section user"><dt></dt><dd>There are no registered simple types recognized by this release of TinyCBOR (beyond those defined by RFC 7049).</dd></dl>
<dl class="section user"><dt>Tag registry</dt><dd>The CBOR specification requires that registration for use of the first 23 tags must be done by way of Standards Action. The next up to tag 255 only require a specification. Finally, all other tags can be registered on a first-come-first-serve basis. The official list can be ontained from <a href="https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml">https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml</a>.</dd></dl>
<dl class="section user"><dt></dt><dd>Given the variability of this list, TinyCBOR cannot recognize all tags registered with IANA. Instead, the implementation only recognizes tags that are backed by an RFC.</dd></dl>
<dl class="section user"><dt></dt><dd>These are the tags known to the current TinyCBOR release: <table class="doxtable">
<tr>
<th>Tag </th><th>Data Item </th><th>Semantics  </th></tr>
<tr>
<td>0 </td><td>UTF-8 text string </td><td>Standard date/time string  </td></tr>
<tr>
<td>1 </td><td>integer </td><td>Epoch-based date/time  </td></tr>
<tr>
<td>2 </td><td>byte string </td><td>Positive bignum  </td></tr>
<tr>
<td>3 </td><td>byte string </td><td>Negative bignum  </td></tr>
<tr>
<td>4 </td><td>array </td><td>Decimal fraction  </td></tr>
<tr>
<td>5 </td><td>array </td><td>Bigfloat  </td></tr>
<tr>
<td>16 </td><td>array </td><td>COSE Single Recipient Encrypted Data Object (RFC 8152)  </td></tr>
<tr>
<td>17 </td><td>array </td><td>COSE Mac w/o Recipients Object (RFC 8152)  </td></tr>
<tr>
<td>18 </td><td>array </td><td>COSE Single Signer Data Object (RFC 8162)  </td></tr>
<tr>
<td>21 </td><td>byte string, array, map </td><td>Expected conversion to base64url encoding  </td></tr>
<tr>
<td>22 </td><td>byte string, array, map </td><td>Expected conversion to base64 encoding  </td></tr>
<tr>
<td>23 </td><td>byte string, array, map </td><td>Expected conversion to base16 encoding  </td></tr>
<tr>
<td>24 </td><td>byte string </td><td>Encoded CBOR data item  </td></tr>
<tr>
<td>32 </td><td>UTF-8 text string </td><td>URI  </td></tr>
<tr>
<td>33 </td><td>UTF-8 text string </td><td>base64url  </td></tr>
<tr>
<td>34 </td><td>UTF-8 text string </td><td>base64  </td></tr>
<tr>
<td>35 </td><td>UTF-8 text string </td><td>Regular expression  </td></tr>
<tr>
<td>36 </td><td>UTF-8 text string </td><td>MIME message  </td></tr>
<tr>
<td>96 </td><td>array </td><td>COSE Encrypted Data Object (RFC 8152)  </td></tr>
<tr>
<td>97 </td><td>array </td><td>COSE MACed Data Object (RFC 8152)  </td></tr>
<tr>
<td>98 </td><td>array </td><td>COSE Signed Data Object (RFC 8152)  </td></tr>
<tr>
<td>55799 </td><td>any </td><td>Self-describe CBOR  </td></tr>
</table>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gadb356bb705f2d8239f03b36081a43b4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_parser_init </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CborParser *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the CBOR parser for parsing <em>size</em> bytes beginning at <em>buffer</em>. </p>
<p>Parsing will use flags set in <em>flags</em>. The iterator to the first element is returned in <em>it</em>.</p>
<p>The <em>parser</em> structure needs to remain valid throughout the decoding process. It is not thread-safe to share one CborParser among multiple threads iterating at the same time, but the object can be copied so multiple threads can iterate. </p>

</div>
</div>
<a class="anchor" id="gae2ede5aacd59f04437c24ef8ca2f449a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances the CBOR value <em>it</em> by one element, skipping over containers. </p>
<p>Unlike <a class="el" href="a00019.html#gac0701f791608589ddfff0bdb8acee7b4" title="Advances the CBOR value it by one fixed-size position. ">cbor_value_advance_fixed()</a>, this function can be called on a CBOR value of any type. However, if the type is a container (map or array) or a string with a chunked payload, this function will not run in constant time and will recurse into itself (it will run on O(n) time for the number of elements or chunks and will use O(n) memory for the number of nested containers).</p>
<p>The number of recursions can be limited at compile time to avoid stack exhaustion in constrained systems.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga49bd2a99edcceb72962eedc7584cd19c" title="Returns true if it has reached the end of the iteration, usually when advancing after the last item i...">cbor_value_at_end()</a>, <a class="el" href="a00019.html#gac0701f791608589ddfff0bdb8acee7b4" title="Advances the CBOR value it by one fixed-size position. ">cbor_value_advance_fixed()</a>, <a class="el" href="a00019.html#ga0c8a61e484973272f34b00cfbef9ddfd" title="Creates a CborValue iterator pointing to the first element of the container represented by it and sav...">cbor_value_enter_container()</a>, <a class="el" href="a00019.html#ga51e02f0b62bc864fe8cf290988936e15" title="Updates it to point to the next element after the container. ">cbor_value_leave_container()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#gaf145f4513ce734265d0128429cc4d5bd">cbor_value_map_find_value()</a>, and <a class="el" href="a00019.html#ga19b60bc2cff3d3ffcc81adbcad09fd58">cbor_value_validate_basic()</a>.</p>

</div>
</div>
<a class="anchor" id="gac0701f791608589ddfff0bdb8acee7b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_advance_fixed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances the CBOR value <em>it</em> by one fixed-size position. </p>
<p>Fixed-size types are: integers, tags, simple types (including boolean, null and undefined values) and floating point types.</p>
<p>If the type is not of fixed size, this function has undefined behavior. Code must be sure that the current type is one of the fixed-size types before calling this function. This function is provided because it can guarantee that runs in constant time (O(1)).</p>
<p>If the caller is not able to determine whether the type is fixed or not, code can use the <a class="el" href="a00019.html#gae2ede5aacd59f04437c24ef8ca2f449a" title="Advances the CBOR value it by one element, skipping over containers. ">cbor_value_advance()</a> function instead.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga49bd2a99edcceb72962eedc7584cd19c" title="Returns true if it has reached the end of the iteration, usually when advancing after the last item i...">cbor_value_at_end()</a>, <a class="el" href="a00019.html#gae2ede5aacd59f04437c24ef8ca2f449a" title="Advances the CBOR value it by one element, skipping over containers. ">cbor_value_advance()</a>, <a class="el" href="a00019.html#ga0c8a61e484973272f34b00cfbef9ddfd" title="Creates a CborValue iterator pointing to the first element of the container represented by it and sav...">cbor_value_enter_container()</a>, <a class="el" href="a00019.html#ga51e02f0b62bc864fe8cf290988936e15" title="Updates it to point to the next element after the container. ">cbor_value_leave_container()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#ga2b805f0f440905a7ba4f93b3569bb97b">cbor_value_skip_tag()</a>.</p>

</div>
</div>
<a class="anchor" id="ga49bd2a99edcceb72962eedc7584cd19c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_at_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <em>it</em> has reached the end of the iteration, usually when advancing after the last item in an array or map. </p>
<p>In the case of the outermost <a class="el" href="a00002.html" title="This type contains one value parsed from the CBOR stream. ">CborValue</a> object, this function returns true after decoding a single element. A pointer to the first byte of the remaining data (if any) can be obtained with <a class="el" href="a00019.html#ga06b1da795150786eb43ee83d65cd17d7" title="Returns a pointer to the next byte that would be decoded if this CborValue object were advanced...">cbor_value_get_next_byte()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae2ede5aacd59f04437c24ef8ca2f449a" title="Advances the CBOR value it by one element, skipping over containers. ">cbor_value_advance()</a>, <a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga06b1da795150786eb43ee83d65cd17d7" title="Returns a pointer to the next byte that would be decoded if this CborValue object were advanced...">cbor_value_get_next_byte()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#gaf145f4513ce734265d0128429cc4d5bd">cbor_value_map_find_value()</a>.</p>

</div>
</div>
<a class="anchor" id="gad5b2dd803244946b15603e09ce147044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_calculate_string_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the length of the byte or text string that <em>value</em> points to and stores it in <em>len</em>. </p>
<p>If the iterator <em>value</em> does not point to a text string or a byte string, the behaviour is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a>, with <a class="el" href="a00019.html#gaed463f5bf4b69d7aec41e6aca9c637ad">cbor_value_is_text_string</a> or <a class="el" href="a00019.html#gad864d46aa7cfa3d57813da2b242380b4">cbor_value_is_byte_string</a> is recommended.</p>
<p>This function is different from <a class="el" href="a00019.html#gaf39519cfc9a8fb64a787348af835569c" title="Extracts the length of the byte or text string that value points to and stores it in result...">cbor_value_get_string_length()</a> in that it calculates the length even for strings sent in chunks. For that reason, this function may not run in constant time (it will run in O(n) time on the number of chunks). It does use constant memory (O(1)).</p>
<dl class="section note"><dt>Note</dt><dd>On 32-bit platforms, this function will return error condition of CborErrorDataTooLarge if the stream indicates a length that is too big to fit in 32-bit.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gaf39519cfc9a8fb64a787348af835569c" title="Extracts the length of the byte or text string that value points to and stores it in result...">cbor_value_get_string_length()</a>, <a class="el" href="a00019.html#ga02ec0b5c8346f407cf5def566ddcf5ae" title="Copies the string pointed by value into the buffer provided at buffer of buflen bytes. ">cbor_value_copy_text_string()</a>, <a class="el" href="a00019.html#gac5204b942fd5e6e1d8064262f3ce96b3" title="Copies the string pointed by value into the buffer provided at buffer of buflen bytes. ">cbor_value_copy_byte_string()</a>, <a class="el" href="a00019.html#ga0422ed961d973d190a19e12a3fe2390f" title="Returns true if the length of this type is known without calculation. ">cbor_value_is_length_known()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac5204b942fd5e6e1d8064262f3ce96b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_copy_byte_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the string pointed by <em>value</em> into the buffer provided at <em>buffer</em> of <em>buflen</em> bytes. </p>
<p>If <em>buffer</em> is a NULL pointer, this function will not copy anything and will only update the <em>next</em> value.</p>
<p>If the iterator <em>value</em> does not point to a byte string, the behaviour is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or <a class="el" href="a00019.html#gad864d46aa7cfa3d57813da2b242380b4">cbor_value_is_byte_string</a> is recommended.</p>
<p>If the provided buffer length was too small, this function returns an error condition of CborErrorOutOfMemory. If you need to calculate the length of the string in order to preallocate a buffer, use <a class="el" href="a00019.html#gad5b2dd803244946b15603e09ce147044" title="Calculates the length of the byte or text string that value points to and stores it in len...">cbor_value_calculate_string_length()</a>.</p>
<p>On success, this function sets the number of bytes copied to <code></code>{*buflen}. If the buffer is large enough, this function will insert a null byte after the last copied byte, to facilitate manipulation of null-terminated strings. That byte is not included in the returned value of <code></code>{*buflen}.</p>
<p>The <em>next</em> pointer, if not null, will be updated to point to the next item after this string. If <em>value</em> points to the last item, then <em>next</em> will be invalid.</p>
<p>This function may not run in constant time (it will run in O(n) time on the number of chunks). It requires constant memory (O(1)).</p>
<dl class="section see"><dt>See Also</dt><dd>cbor_value_get_byte_string_chunk(), <a class="el" href="a00004.html#a4365a3a12a36871dd84006b9d19fd9ed" title="Allocates memory for the string pointed by value and copies it into this buffer. ">cbor_value_dup_text_string()</a>, <a class="el" href="a00019.html#ga02ec0b5c8346f407cf5def566ddcf5ae" title="Copies the string pointed by value into the buffer provided at buffer of buflen bytes. ">cbor_value_copy_text_string()</a>, <a class="el" href="a00019.html#gaf39519cfc9a8fb64a787348af835569c" title="Extracts the length of the byte or text string that value points to and stores it in result...">cbor_value_get_string_length()</a>, <a class="el" href="a00019.html#gad5b2dd803244946b15603e09ce147044" title="Calculates the length of the byte or text string that value points to and stores it in len...">cbor_value_calculate_string_length()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga02ec0b5c8346f407cf5def566ddcf5ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_copy_text_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the string pointed by <em>value</em> into the buffer provided at <em>buffer</em> of <em>buflen</em> bytes. </p>
<p>If <em>buffer</em> is a NULL pointer, this function will not copy anything and will only update the <em>next</em> value.</p>
<p>If the iterator <em>value</em> does not point to a text string, the behaviour is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or <a class="el" href="a00019.html#gaed463f5bf4b69d7aec41e6aca9c637ad">cbor_value_is_text_string</a> is recommended.</p>
<p>If the provided buffer length was too small, this function returns an error condition of CborErrorOutOfMemory. If you need to calculate the length of the string in order to preallocate a buffer, use <a class="el" href="a00019.html#gad5b2dd803244946b15603e09ce147044" title="Calculates the length of the byte or text string that value points to and stores it in len...">cbor_value_calculate_string_length()</a>.</p>
<p>On success, this function sets the number of bytes copied to <code></code>{*buflen}. If the buffer is large enough, this function will insert a null byte after the last copied byte, to facilitate manipulation of text strings. That byte is not included in the returned value of <code></code>{*buflen}.</p>
<p>The <em>next</em> pointer, if not null, will be updated to point to the next item after this string. If <em>value</em> points to the last item, then <em>next</em> will be invalid.</p>
<p>This function may not run in constant time (it will run in O(n) time on the number of chunks). It requires constant memory (O(1)).</p>
<dl class="section note"><dt>Note</dt><dd>This function does not perform UTF-8 validation on the incoming text string.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gacb1070d99c7094657271ef914b40a91b" title="Extracts one text string chunk pointed to by value and stores a pointer to the data in buffer and the...">cbor_value_get_text_string_chunk()</a> <a class="el" href="a00004.html#a4365a3a12a36871dd84006b9d19fd9ed" title="Allocates memory for the string pointed by value and copies it into this buffer. ">cbor_value_dup_text_string()</a>, <a class="el" href="a00019.html#gac5204b942fd5e6e1d8064262f3ce96b3" title="Copies the string pointed by value into the buffer provided at buffer of buflen bytes. ">cbor_value_copy_byte_string()</a>, <a class="el" href="a00019.html#gaf39519cfc9a8fb64a787348af835569c" title="Extracts the length of the byte or text string that value points to and stores it in result...">cbor_value_get_string_length()</a>, <a class="el" href="a00019.html#gad5b2dd803244946b15603e09ce147044" title="Calculates the length of the byte or text string that value points to and stores it in len...">cbor_value_calculate_string_length()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c8a61e484973272f34b00cfbef9ddfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_enter_container </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>recursed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="a00002.html" title="This type contains one value parsed from the CBOR stream. ">CborValue</a> iterator pointing to the first element of the container represented by <em>it</em> and saves it in <em>recursed</em>. </p>
<p>The <em>it</em> container object needs to be kept and passed again to <a class="el" href="a00019.html#ga51e02f0b62bc864fe8cf290988936e15" title="Updates it to point to the next element after the container. ">cbor_value_leave_container()</a> in order to continue iterating past this container.</p>
<p>The <em>it</em> <a class="el" href="a00002.html" title="This type contains one value parsed from the CBOR stream. ">CborValue</a> iterator must point to a container.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gaf3da16a547bcb54d3ad2ca70cf0f4341" title="Returns true if the it value is a container and requires recursion in order to decode (maps and array...">cbor_value_is_container()</a>, <a class="el" href="a00019.html#ga51e02f0b62bc864fe8cf290988936e15" title="Updates it to point to the next element after the container. ">cbor_value_leave_container()</a>, <a class="el" href="a00019.html#gae2ede5aacd59f04437c24ef8ca2f449a" title="Advances the CBOR value it by one element, skipping over containers. ">cbor_value_advance()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#gaf145f4513ce734265d0128429cc4d5bd">cbor_value_map_find_value()</a>.</p>

</div>
</div>
<a class="anchor" id="gae3dec7120c8ce4326aea96c6eec6090c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_array_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the length of the CBOR array that <em>value</em> points to and stores it in <em>result</em>. </p>
<p>If the iterator <em>value</em> does not point to a CBOR array, the behaviour is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or <a class="el" href="a00019.html#gadf427a0fdeb50f7a94d3c3620dd36161">cbor_value_is_array</a> is recommended.</p>
<p>If the length of this array is not encoded in the CBOR data stream, this function will return the recoverable error CborErrorUnknownLength. You may also check whether that is the case by using <a class="el" href="a00019.html#ga0422ed961d973d190a19e12a3fe2390f" title="Returns true if the length of this type is known without calculation. ">cbor_value_is_length_known()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>On 32-bit platforms, this function will return error condition of CborErrorDataTooLarge if the stream indicates a length that is too big to fit in 32-bit.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga0422ed961d973d190a19e12a3fe2390f" title="Returns true if the length of this type is known without calculation. ">cbor_value_is_length_known()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gade7bfd61f35e448b1119d9bcfce234c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_boolean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the boolean value that <em>value</em> points to and stores it in <em>result</em>. </p>
<p>If the iterator <em>value</em> does not point to a boolean value, the behavior is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or with <a class="el" href="a00019.html#ga0f85ec6748006a36c237a79d6f223b29">cbor_value_is_boolean</a> is recommended.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5" title="Returns the type of the CBOR value that the iterator value points to. ">cbor_value_get_type()</a>, <a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga0f85ec6748006a36c237a79d6f223b29" title="Returns true if the iterator value is valid and points to a CBOR boolean type (true or false)...">cbor_value_is_boolean()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafcb81c2eeff3cc6dab0f2da699bb564b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_float </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the CBOR single-precision floating point (32-bit) value that <em>value</em> points to and stores it in <em>result</em>. </p>
<p>If the iterator <em>value</em> does not point to a single-precision floating point value, the behavior is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or with <a class="el" href="a00019.html#gafda7173c376b4789887db1717ef3f1b8">cbor_value_is_float</a> is recommended.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5" title="Returns the type of the CBOR value that the iterator value points to. ">cbor_value_get_type()</a>, <a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#gafda7173c376b4789887db1717ef3f1b8" title="Returns true if the iterator value is valid and points to a CBOR single-precision floating point (32-...">cbor_value_is_float()</a>, cbor_value_get_double() </dd></dl>

</div>
</div>
<a class="anchor" id="ga566e51dcf54db8eb43ec19e8d31b8c6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_half_float </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the CBOR half-precision floating point (16-bit) value that <em>value</em> points to and stores it in <em>result</em>. </p>
<p>If the iterator <em>value</em> does not point to a half-precision floating point value, the behavior is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or with <a class="el" href="a00019.html#gab44b87547a7c5a028479354d2f66c46c">cbor_value_is_half_float</a> is recommended.</p>
<p>Note: since the C language does not have a standard type for half-precision floating point, this function takes a <code></code>{void *} as a parameter for the storage area, which must be at least 16 bits wide.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5" title="Returns the type of the CBOR value that the iterator value points to. ">cbor_value_get_type()</a>, <a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#gab44b87547a7c5a028479354d2f66c46c" title="Returns true if the iterator value is valid and points to a CBOR single-precision floating point (16-...">cbor_value_is_half_float()</a>, <a class="el" href="a00019.html#gafcb81c2eeff3cc6dab0f2da699bb564b" title="Retrieves the CBOR single-precision floating point (32-bit) value that value points to and stores it ...">cbor_value_get_float()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabf95f402facf8436989b830f1dd4b06a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the CBOR integer value that <em>value</em> points to and stores it in <em>result</em>. </p>
<p>If the iterator <em>value</em> does not point to an integer value, the behavior is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or with <a class="el" href="a00019.html#ga3ea2ca067d876ca95251005f4ad696b0">cbor_value_is_integer</a> is recommended.</p>
<p>Note that this function does not do range-checking: integral values that do not fit in a variable of type <code></code>{int} are silently truncated to fit. Use <a class="el" href="a00019.html#gaf9b7aba18f57c255e744b874645ac9be" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_int_checked()</a> that is not acceptable.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5" title="Returns the type of the CBOR value that the iterator value points to. ">cbor_value_get_type()</a>, <a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga3ea2ca067d876ca95251005f4ad696b0" title="Returns true if the iterator value is valid and points to a CBOR integer type. ">cbor_value_is_integer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae16139e4a8857033b908dad98ddb2ac3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_int64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the CBOR integer value that <em>value</em> points to and stores it in <em>result</em>. </p>
<p>If the iterator <em>value</em> does not point to an integer value, the behavior is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or with <a class="el" href="a00019.html#ga3ea2ca067d876ca95251005f4ad696b0">cbor_value_is_integer</a> is recommended.</p>
<p>Note that this function does not do range-checking: integral values that do not fit in a variable of type <code></code>{int64_t} are silently truncated to fit. Use <a class="el" href="a00019.html#ga5bd9f8ab2b61aaeb31fd9b724622f0df" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_int64_checked()</a> that is not acceptable.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5" title="Returns the type of the CBOR value that the iterator value points to. ">cbor_value_get_type()</a>, <a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga3ea2ca067d876ca95251005f4ad696b0" title="Returns true if the iterator value is valid and points to a CBOR integer type. ">cbor_value_is_integer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5bd9f8ab2b61aaeb31fd9b724622f0df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_int64_checked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the CBOR integer value that <em>value</em> points to and stores it in <em>result</em>. </p>
<p>If the iterator <em>value</em> does not point to an integer value, the behavior is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or with <a class="el" href="a00019.html#ga3ea2ca067d876ca95251005f4ad696b0">cbor_value_is_integer</a> is recommended.</p>
<p>Unlike <a class="el" href="a00019.html#gae16139e4a8857033b908dad98ddb2ac3" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_int64()</a>, this function performs a check to see if the stored integer fits in <em>result</em> without data loss. If the number is outside the valid range for the data type, this function returns the recoverable error CborErrorDataTooLarge. In that case, use either <a class="el" href="a00019.html#gab4c30532c395047b62ccc7c7eeb3a51b" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_uint64()</a> (if the number is positive) or <a class="el" href="a00019.html#ga30c4dc9fb923feac58d962b02aeecd41" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_raw_integer()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5" title="Returns the type of the CBOR value that the iterator value points to. ">cbor_value_get_type()</a>, <a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga3ea2ca067d876ca95251005f4ad696b0" title="Returns true if the iterator value is valid and points to a CBOR integer type. ">cbor_value_is_integer()</a>, <a class="el" href="a00019.html#gae16139e4a8857033b908dad98ddb2ac3" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_int64()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf9b7aba18f57c255e744b874645ac9be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_int_checked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the CBOR integer value that <em>value</em> points to and stores it in <em>result</em>. </p>
<p>If the iterator <em>value</em> does not point to an integer value, the behavior is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or with <a class="el" href="a00019.html#ga3ea2ca067d876ca95251005f4ad696b0">cbor_value_is_integer</a> is recommended.</p>
<p>Unlike <a class="el" href="a00019.html#gabf95f402facf8436989b830f1dd4b06a" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_int()</a>, this function performs a check to see if the stored integer fits in <em>result</em> without data loss. If the number is outside the valid range for the data type, this function returns the recoverable error CborErrorDataTooLarge. In that case, use one of the other integer functions to obtain the value.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5" title="Returns the type of the CBOR value that the iterator value points to. ">cbor_value_get_type()</a>, <a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga3ea2ca067d876ca95251005f4ad696b0" title="Returns true if the iterator value is valid and points to a CBOR integer type. ">cbor_value_is_integer()</a>, <a class="el" href="a00019.html#gae16139e4a8857033b908dad98ddb2ac3" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_int64()</a>, <a class="el" href="a00019.html#gab4c30532c395047b62ccc7c7eeb3a51b" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_uint64()</a>, <a class="el" href="a00019.html#ga5bd9f8ab2b61aaeb31fd9b724622f0df" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_int64_checked()</a>, <a class="el" href="a00019.html#ga30c4dc9fb923feac58d962b02aeecd41" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_raw_integer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad82740107f90881f83e7fb44ed74674b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_map_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the length of the CBOR map that <em>value</em> points to and stores it in <em>result</em>. </p>
<p>If the iterator <em>value</em> does not point to a CBOR map, the behaviour is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or <a class="el" href="a00019.html#ga1b34d5f429a4c77f451391c4f7dff497">cbor_value_is_map</a> is recommended.</p>
<p>If the length of this map is not encoded in the CBOR data stream, this function will return the recoverable error CborErrorUnknownLength. You may also check whether that is the case by using <a class="el" href="a00019.html#ga0422ed961d973d190a19e12a3fe2390f" title="Returns true if the length of this type is known without calculation. ">cbor_value_is_length_known()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>On 32-bit platforms, this function will return error condition of CborErrorDataTooLarge if the stream indicates a length that is too big to fit in 32-bit.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga0422ed961d973d190a19e12a3fe2390f" title="Returns true if the length of this type is known without calculation. ">cbor_value_is_length_known()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga06b1da795150786eb43ee83d65cd17d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * cbor_value_get_next_byte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the next byte that would be decoded if this <a class="el" href="a00002.html" title="This type contains one value parsed from the CBOR stream. ">CborValue</a> object were advanced. </p>
<p>This function is useful if <a class="el" href="a00019.html#ga49bd2a99edcceb72962eedc7584cd19c" title="Returns true if it has reached the end of the iteration, usually when advancing after the last item i...">cbor_value_at_end()</a> returns true for the outermost <a class="el" href="a00002.html" title="This type contains one value parsed from the CBOR stream. ">CborValue</a>: the pointer returned is the first byte of the data remaining in the buffer, if any. Code can decide whether to begin decoding a new CBOR data stream from this point, or parse some other data appended to the same buffer.</p>
<p>This function may be used even after a parsing error. If that occurred, then this function returns a pointer to where the parsing error occurred. Note that the error recovery is not precise and the pointer may not indicate the exact byte containing bad data.</p>
<p>This function makes sense only when using a linear buffer (that is, when the parser is initialize by <a class="el" href="a00019.html#gadb356bb705f2d8239f03b36081a43b4f" title="Initializes the CBOR parser for parsing size bytes beginning at buffer. ">cbor_parser_init()</a>). If using an external source, this function may return garbage; instead, consult the external source itself to find out more details about the presence of more data.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga49bd2a99edcceb72962eedc7584cd19c" title="Returns true if it has reached the end of the iteration, usually when advancing after the last item i...">cbor_value_at_end()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga30c4dc9fb923feac58d962b02aeecd41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_raw_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the CBOR integer value that <em>value</em> points to and stores it in <em>result</em>. </p>
<p>If the iterator <em>value</em> does not point to an integer value, the behavior is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or with <a class="el" href="a00019.html#ga3ea2ca067d876ca95251005f4ad696b0">cbor_value_is_integer</a> is recommended.</p>
<p>This function is provided because CBOR negative integers can assume values that cannot be represented with normal 64-bit integer variables.</p>
<p>If the integer is unsigned (that is, if <a class="el" href="a00019.html#gac6aaf9010ea974034fe62b4670e44235" title="Returns true if the iterator value is valid and points to a CBOR unsigned integer type (positive valu...">cbor_value_is_unsigned_integer()</a> returns true), then <em>result</em> will contain the actual value. If the integer is negative, then <em>result</em> will contain the absolute value of that integer, minus one. That is, <code>{actual</code> = -result - 1}. On architectures using two's complement for representation of negative integers, it is equivalent to say that <em>result</em> will contain the bitwise negation of the actual value.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5" title="Returns the type of the CBOR value that the iterator value points to. ">cbor_value_get_type()</a>, <a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga3ea2ca067d876ca95251005f4ad696b0" title="Returns true if the iterator value is valid and points to a CBOR integer type. ">cbor_value_is_integer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga033d3d2c9570501cf9dce099fe98e863"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_simple_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the CBOR Simple Type value that <em>value</em> points to and stores it in <em>result</em>. </p>
<p>If the iterator <em>value</em> does not point to a simple_type value, the behavior is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or with <a class="el" href="a00019.html#gaae1a1b893975549d5fa74452ba4b79e8">cbor_value_is_simple_type</a> is recommended.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5" title="Returns the type of the CBOR value that the iterator value points to. ">cbor_value_get_type()</a>, <a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#gaae1a1b893975549d5fa74452ba4b79e8" title="Returns true if the iterator value is valid and points to a CBOR Simple Type type (other than true...">cbor_value_is_simple_type()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf39519cfc9a8fb64a787348af835569c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_string_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the length of the byte or text string that <em>value</em> points to and stores it in <em>result</em>. </p>
<p>If the iterator <em>value</em> does not point to a text string or a byte string, the behaviour is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a>, with <a class="el" href="a00019.html#gaed463f5bf4b69d7aec41e6aca9c637ad">cbor_value_is_text_string</a> or <a class="el" href="a00019.html#gad864d46aa7cfa3d57813da2b242380b4">cbor_value_is_byte_string</a> is recommended.</p>
<p>If the length of this string is not encoded in the CBOR data stream, this function will return the recoverable error CborErrorUnknownLength. You may also check whether that is the case by using <a class="el" href="a00019.html#ga0422ed961d973d190a19e12a3fe2390f" title="Returns true if the length of this type is known without calculation. ">cbor_value_is_length_known()</a>.</p>
<p>If the length of the string is required but the length was not encoded, use <a class="el" href="a00019.html#gad5b2dd803244946b15603e09ce147044" title="Calculates the length of the byte or text string that value points to and stores it in len...">cbor_value_calculate_string_length()</a>, but note that that function does not run in constant time.</p>
<dl class="section note"><dt>Note</dt><dd>On 32-bit platforms, this function will return error condition of CborErrorDataTooLarge if the stream indicates a length that is too big to fit in 32-bit.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga0422ed961d973d190a19e12a3fe2390f" title="Returns true if the length of this type is known without calculation. ">cbor_value_is_length_known()</a>, <a class="el" href="a00019.html#gad5b2dd803244946b15603e09ce147044" title="Calculates the length of the byte or text string that value points to and stores it in len...">cbor_value_calculate_string_length()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ee8cd4c95df1d788f5ef8fee6ac101a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00017.html#ga46c29d9d57408740dc269d6125d37d26">CborTag</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the CBOR tag value that <em>value</em> points to and stores it in <em>result</em>. </p>
<p>If the iterator <em>value</em> does not point to a CBOR tag value, the behavior is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or with <a class="el" href="a00019.html#ga283d20b9bd9787647841dd245d486b1d">cbor_value_is_tag</a> is recommended.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5" title="Returns the type of the CBOR value that the iterator value points to. ">cbor_value_get_type()</a>, <a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga283d20b9bd9787647841dd245d486b1d" title="Returns true if the iterator value is valid and points to a CBOR tag. ">cbor_value_is_tag()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacb1070d99c7094657271ef914b40a91b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_text_string_chunk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>bufferptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts one text string chunk pointed to by <em>value</em> and stores a pointer to the data in <em>buffer</em> and the size in <em>len</em>, which must not be null. </p>
<p>If no more chunks are available, then <em>bufferptr</em> will be set to null. This function may be used to iterate over any string without causing its contents to be copied to a separate buffer, like the convenience function <a class="el" href="a00019.html#ga02ec0b5c8346f407cf5def566ddcf5ae" title="Copies the string pointed by value into the buffer provided at buffer of buflen bytes. ">cbor_value_copy_text_string()</a> does.</p>
<p>It is designed to be used in code like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="a00019.html#gaed463f5bf4b69d7aec41e6aca9c637ad">cbor_value_is_text_string</a>(value)) {</div>
<div class="line">    <span class="keywordtype">char</span> *ptr;</div>
<div class="line">    <span class="keywordtype">size_t</span> len;</div>
<div class="line">    <span class="keywordflow">while</span> (1) {</div>
<div class="line">        err = <a class="code" href="a00019.html#gacb1070d99c7094657271ef914b40a91b">cbor_value_get_text_string_chunk</a>(value, &amp;ptr, &amp;len, &amp;value));</div>
<div class="line">        <span class="keywordflow">if</span> (err) <span class="keywordflow">return</span> err;</div>
<div class="line">        <span class="keywordflow">if</span> (ptr == NULL) <span class="keywordflow">return</span> CborNoError;</div>
<div class="line">        consume(ptr, len);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>If the iterator <em>value</em> does not point to a text string, the behaviour is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or <a class="el" href="a00019.html#gaed463f5bf4b69d7aec41e6aca9c637ad">cbor_value_is_text_string</a> is recommended.</p>
<p>The <em>next</em> pointer, if not null, will be updated to point to the next item after this string. During iteration, the pointer must only be passed back again to this function; passing it to any other function in this library results in undefined behavior. If there are no more chunks to be read from <em>value</em>, then <em>next</em> will be set to the next item after this string; if <em>value</em> points to the last item, then <em>next</em> will be invalid.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not perform UTF-8 validation on the incoming text string.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00004.html#a4365a3a12a36871dd84006b9d19fd9ed" title="Allocates memory for the string pointed by value and copies it into this buffer. ">cbor_value_dup_text_string()</a>, <a class="el" href="a00019.html#ga02ec0b5c8346f407cf5def566ddcf5ae" title="Copies the string pointed by value into the buffer provided at buffer of buflen bytes. ">cbor_value_copy_text_string()</a>, cbor_value_caculate_string_length(), cbor_value_get_byte_string_chunk() </dd></dl>

</div>
</div>
<a class="anchor" id="ga49bb974313534553ccafb28e5eba46d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga38f51ceba8bc8a9b1cf7dd31e3f9c178">CborType</a> cbor_value_get_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type of the CBOR value that the iterator <em>value</em> points to. </p>
<p>If <em>value</em> does not point to a valid value, this function returns CborInvalidType.</p>
<p>TinyCBOR also provides functions to test directly if a given <a class="el" href="a00002.html" title="This type contains one value parsed from the CBOR stream. ">CborValue</a> object is of a given type, like <a class="el" href="a00019.html#gaed463f5bf4b69d7aec41e6aca9c637ad" title="Returns true if the iterator value is valid and points to a CBOR text string. ">cbor_value_is_text_string()</a> and <a class="el" href="a00019.html#ga11f38fada70d371257f7b51f311e8826" title="Returns true if the iterator value is valid and points to a CBOR null type. ">cbor_value_is_null()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00021.html#ga558485bab0ebcb2646e7669d13861d79">cbor_value_to_json_advance()</a>.</p>

</div>
</div>
<a class="anchor" id="gab4c30532c395047b62ccc7c7eeb3a51b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_get_uint64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the CBOR integer value that <em>value</em> points to and stores it in <em>result</em>. </p>
<p>If the iterator <em>value</em> does not point to an unsigned integer value, the behavior is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or with <a class="el" href="a00019.html#gac6aaf9010ea974034fe62b4670e44235">cbor_value_is_unsigned_integer</a> is recommended.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5" title="Returns the type of the CBOR value that the iterator value points to. ">cbor_value_get_type()</a>, <a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#gac6aaf9010ea974034fe62b4670e44235" title="Returns true if the iterator value is valid and points to a CBOR unsigned integer type (positive valu...">cbor_value_is_unsigned_integer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadf427a0fdeb50f7a94d3c3620dd36161"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR array. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga1b34d5f429a4c77f451391c4f7dff497" title="Returns true if the iterator value is valid and points to a CBOR map. ">cbor_value_is_map()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#gae3dec7120c8ce4326aea96c6eec6090c">cbor_value_get_array_length()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f85ec6748006a36c237a79d6f223b29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_boolean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR boolean type (true or false). </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#gade7bfd61f35e448b1119d9bcfce234c0" title="Retrieves the boolean value that value points to and stores it in result. ">cbor_value_get_boolean()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#gade7bfd61f35e448b1119d9bcfce234c0">cbor_value_get_boolean()</a>.</p>

</div>
</div>
<a class="anchor" id="gad864d46aa7cfa3d57813da2b242380b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_byte_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR text string. </p>
<p>CBOR byte strings are binary data with no specified encoding or format.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#gaf39519cfc9a8fb64a787348af835569c" title="Extracts the length of the byte or text string that value points to and stores it in result...">cbor_value_get_string_length()</a>, <a class="el" href="a00019.html#gad5b2dd803244946b15603e09ce147044" title="Calculates the length of the byte or text string that value points to and stores it in len...">cbor_value_calculate_string_length()</a>, <a class="el" href="a00019.html#gac5204b942fd5e6e1d8064262f3ce96b3" title="Copies the string pointed by value into the buffer provided at buffer of buflen bytes. ">cbor_value_copy_byte_string()</a>, <a class="el" href="a00004.html#adf17ef706737dc8c30d7a424d6bfc4b9" title="Allocates memory for the string pointed by value and copies it into this buffer. ">cbor_value_dup_byte_string()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#gac5204b942fd5e6e1d8064262f3ce96b3">cbor_value_copy_byte_string()</a>, <a class="el" href="a00004.html#adf17ef706737dc8c30d7a424d6bfc4b9">cbor_value_dup_byte_string()</a>, and <a class="el" href="a00019.html#gaf39519cfc9a8fb64a787348af835569c">cbor_value_get_string_length()</a>.</p>

</div>
</div>
<a class="anchor" id="ga911e93729874ae5a2b4560c5bfe83ec3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_double </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR double-precision floating point (64-bit). </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#gafda7173c376b4789887db1717ef3f1b8" title="Returns true if the iterator value is valid and points to a CBOR single-precision floating point (32-...">cbor_value_is_float()</a>, <a class="el" href="a00019.html#gab44b87547a7c5a028479354d2f66c46c" title="Returns true if the iterator value is valid and points to a CBOR single-precision floating point (16-...">cbor_value_is_half_float()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafda7173c376b4789887db1717ef3f1b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_float </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR single-precision floating point (32-bit). </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga911e93729874ae5a2b4560c5bfe83ec3" title="Returns true if the iterator value is valid and points to a CBOR double-precision floating point (64-...">cbor_value_is_double()</a>, <a class="el" href="a00019.html#gab44b87547a7c5a028479354d2f66c46c" title="Returns true if the iterator value is valid and points to a CBOR single-precision floating point (16-...">cbor_value_is_half_float()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#gafcb81c2eeff3cc6dab0f2da699bb564b">cbor_value_get_float()</a>.</p>

</div>
</div>
<a class="anchor" id="gab44b87547a7c5a028479354d2f66c46c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_half_float </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR single-precision floating point (16-bit). </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga911e93729874ae5a2b4560c5bfe83ec3" title="Returns true if the iterator value is valid and points to a CBOR double-precision floating point (64-...">cbor_value_is_double()</a>, <a class="el" href="a00019.html#gafda7173c376b4789887db1717ef3f1b8" title="Returns true if the iterator value is valid and points to a CBOR single-precision floating point (32-...">cbor_value_is_float()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#ga566e51dcf54db8eb43ec19e8d31b8c6f">cbor_value_get_half_float()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3ea2ca067d876ca95251005f4ad696b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR integer type. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#gabf95f402facf8436989b830f1dd4b06a" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_int</a>, <a class="el" href="a00019.html#gae16139e4a8857033b908dad98ddb2ac3" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_int64</a>, <a class="el" href="a00019.html#gab4c30532c395047b62ccc7c7eeb3a51b" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_uint64</a>, <a class="el" href="a00019.html#ga30c4dc9fb923feac58d962b02aeecd41" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_raw_integer</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#gabf95f402facf8436989b830f1dd4b06a">cbor_value_get_int()</a>, <a class="el" href="a00019.html#gae16139e4a8857033b908dad98ddb2ac3">cbor_value_get_int64()</a>, <a class="el" href="a00019.html#ga5bd9f8ab2b61aaeb31fd9b724622f0df">cbor_value_get_int64_checked()</a>, <a class="el" href="a00019.html#gaf9b7aba18f57c255e744b874645ac9be">cbor_value_get_int_checked()</a>, <a class="el" href="a00019.html#ga30c4dc9fb923feac58d962b02aeecd41">cbor_value_get_raw_integer()</a>, <a class="el" href="a00019.html#gaaecdd62ea0656b7c4b367b19648ac79b">cbor_value_is_negative_integer()</a>, and <a class="el" href="a00019.html#gac6aaf9010ea974034fe62b4670e44235">cbor_value_is_unsigned_integer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0422ed961d973d190a19e12a3fe2390f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_length_known </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the length of this type is known without calculation. </p>
<p>That is, if the length of this CBOR string, map or array is encoded in the data stream, this function returns true. If the length is not encoded, it returns false.</p>
<p>If the length is known, code can call <a class="el" href="a00019.html#gaf39519cfc9a8fb64a787348af835569c" title="Extracts the length of the byte or text string that value points to and stores it in result...">cbor_value_get_string_length()</a>, <a class="el" href="a00019.html#gae3dec7120c8ce4326aea96c6eec6090c" title="Extracts the length of the CBOR array that value points to and stores it in result. ">cbor_value_get_array_length()</a> or <a class="el" href="a00019.html#gad82740107f90881f83e7fb44ed74674b" title="Extracts the length of the CBOR map that value points to and stores it in result. ...">cbor_value_get_map_length()</a> to obtain the length. If the length is not known but is necessary, code can use the <a class="el" href="a00019.html#gad5b2dd803244946b15603e09ce147044" title="Calculates the length of the byte or text string that value points to and stores it in len...">cbor_value_calculate_string_length()</a> function (no equivalent function is provided for maps and arrays). </p>

<p>Referenced by <a class="el" href="a00019.html#gae3dec7120c8ce4326aea96c6eec6090c">cbor_value_get_array_length()</a>, <a class="el" href="a00019.html#gad82740107f90881f83e7fb44ed74674b">cbor_value_get_map_length()</a>, and <a class="el" href="a00019.html#gaf39519cfc9a8fb64a787348af835569c">cbor_value_get_string_length()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1b34d5f429a4c77f451391c4f7dff497"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR map. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#gadf427a0fdeb50f7a94d3c3620dd36161" title="Returns true if the iterator value is valid and points to a CBOR array. ">cbor_value_is_array()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#gad82740107f90881f83e7fb44ed74674b">cbor_value_get_map_length()</a>, and <a class="el" href="a00019.html#gaf145f4513ce734265d0128429cc4d5bd">cbor_value_map_find_value()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaecdd62ea0656b7c4b367b19648ac79b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_negative_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR negative integer type. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#gabf95f402facf8436989b830f1dd4b06a" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_int</a>, <a class="el" href="a00019.html#gae16139e4a8857033b908dad98ddb2ac3" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_int64</a>, <a class="el" href="a00019.html#ga30c4dc9fb923feac58d962b02aeecd41" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_raw_integer</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga11f38fada70d371257f7b51f311e8826"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_null </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR null type. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga1079ce3272f905c3d4a20821507be6f6" title="Returns true if the iterator value is valid and points to a CBOR undefined type. ">cbor_value_is_undefined()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaae1a1b893975549d5fa74452ba4b79e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_simple_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR Simple Type type (other than true, false, null and undefined). </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga033d3d2c9570501cf9dce099fe98e863" title="Retrieves the CBOR Simple Type value that value points to and stores it in result. ">cbor_value_get_simple_type()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#ga033d3d2c9570501cf9dce099fe98e863">cbor_value_get_simple_type()</a>.</p>

</div>
</div>
<a class="anchor" id="ga283d20b9bd9787647841dd245d486b1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR tag. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga4ee8cd4c95df1d788f5ef8fee6ac101a" title="Retrieves the CBOR tag value that value points to and stores it in result. ">cbor_value_get_tag()</a>, <a class="el" href="a00019.html#ga2b805f0f440905a7ba4f93b3569bb97b" title="Advances the CBOR value it until it no longer points to a tag. ">cbor_value_skip_tag()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#ga4ee8cd4c95df1d788f5ef8fee6ac101a">cbor_value_get_tag()</a>, and <a class="el" href="a00019.html#ga2b805f0f440905a7ba4f93b3569bb97b">cbor_value_skip_tag()</a>.</p>

</div>
</div>
<a class="anchor" id="gaed463f5bf4b69d7aec41e6aca9c637ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_text_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR text string. </p>
<p>CBOR text strings are UTF-8 encoded and usually contain human-readable text.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#gaf39519cfc9a8fb64a787348af835569c" title="Extracts the length of the byte or text string that value points to and stores it in result...">cbor_value_get_string_length()</a>, <a class="el" href="a00019.html#gad5b2dd803244946b15603e09ce147044" title="Calculates the length of the byte or text string that value points to and stores it in len...">cbor_value_calculate_string_length()</a>, <a class="el" href="a00019.html#ga02ec0b5c8346f407cf5def566ddcf5ae" title="Copies the string pointed by value into the buffer provided at buffer of buflen bytes. ">cbor_value_copy_text_string()</a>, <a class="el" href="a00004.html#a4365a3a12a36871dd84006b9d19fd9ed" title="Allocates memory for the string pointed by value and copies it into this buffer. ">cbor_value_dup_text_string()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#ga02ec0b5c8346f407cf5def566ddcf5ae">cbor_value_copy_text_string()</a>, <a class="el" href="a00004.html#a4365a3a12a36871dd84006b9d19fd9ed">cbor_value_dup_text_string()</a>, <a class="el" href="a00019.html#gaf39519cfc9a8fb64a787348af835569c">cbor_value_get_string_length()</a>, <a class="el" href="a00019.html#gacb1070d99c7094657271ef914b40a91b">cbor_value_get_text_string_chunk()</a>, <a class="el" href="a00019.html#gaf145f4513ce734265d0128429cc4d5bd">cbor_value_map_find_value()</a>, and <a class="el" href="a00019.html#gac8f08df74d65c8454528824a667550ec">cbor_value_text_string_equals()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1079ce3272f905c3d4a20821507be6f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_undefined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR undefined type. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#ga11f38fada70d371257f7b51f311e8826" title="Returns true if the iterator value is valid and points to a CBOR null type. ">cbor_value_is_null()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac6aaf9010ea974034fe62b4670e44235"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_unsigned_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>value</em> is valid and points to a CBOR unsigned integer type (positive values or zero). </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#gab4c30532c395047b62ccc7c7eeb3a51b" title="Retrieves the CBOR integer value that value points to and stores it in result. ">cbor_value_get_uint64()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#gab4c30532c395047b62ccc7c7eeb3a51b">cbor_value_get_uint64()</a>.</p>

</div>
</div>
<a class="anchor" id="gae8bf13b3880863cf5c8a0bddf52426e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cbor_value_is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the iterator <em>it</em> contains a valid value. </p>
<p>Invalid iterators happen when iteration reaches the end of a container (see <a class="el" href="a00019.html#ga49bd2a99edcceb72962eedc7584cd19c">cbor_value_at_end()</a>) or when a search function resulted in no matches.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae2ede5aacd59f04437c24ef8ca2f449a" title="Advances the CBOR value it by one element, skipping over containers. ">cbor_value_advance()</a>, cbor_valie_at_end(), <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5" title="Returns the type of the CBOR value that the iterator value points to. ">cbor_value_get_type()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga51e02f0b62bc864fe8cf290988936e15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_leave_container </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>recursed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <em>it</em> to point to the next element after the container. </p>
<p>The <em>recursed</em> object needs to point to the element obtained either by advancing the last element of the container (via <a class="el" href="a00019.html#gae2ede5aacd59f04437c24ef8ca2f449a" title="Advances the CBOR value it by one element, skipping over containers. ">cbor_value_advance()</a>, <a class="el" href="a00019.html#gac0701f791608589ddfff0bdb8acee7b4" title="Advances the CBOR value it by one fixed-size position. ">cbor_value_advance_fixed()</a>, a nested <a class="el" href="a00019.html#ga51e02f0b62bc864fe8cf290988936e15" title="Updates it to point to the next element after the container. ">cbor_value_leave_container()</a>, or the <code>next</code> pointer from cbor_value_copy_string() or cbor_value_dup_string()).</p>
<p>The <em>it</em> and <em>recursed</em> parameters must be the exact same as passed to <a class="el" href="a00019.html#ga0c8a61e484973272f34b00cfbef9ddfd" title="Creates a CborValue iterator pointing to the first element of the container represented by it and sav...">cbor_value_enter_container()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga0c8a61e484973272f34b00cfbef9ddfd" title="Creates a CborValue iterator pointing to the first element of the container represented by it and sav...">cbor_value_enter_container()</a>, <a class="el" href="a00019.html#ga49bd2a99edcceb72962eedc7584cd19c" title="Returns true if it has reached the end of the iteration, usually when advancing after the last item i...">cbor_value_at_end()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf145f4513ce734265d0128429cc4d5bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_map_find_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find the value in map <em>map</em> that corresponds to the text string entry <em>string</em>. </p>
<p>If the iterator <em>value</em> does not point to a CBOR map, the behaviour is undefined, so checking with <a class="el" href="a00019.html#ga49bb974313534553ccafb28e5eba46d5">cbor_value_get_type</a> or <a class="el" href="a00019.html#ga1b34d5f429a4c77f451391c4f7dff497">cbor_value_is_map</a> is recommended.</p>
<p>If the item is found, it is stored in <em>result</em>. If no item is found matching the key, then <em>result</em> will contain an element of type CborInvalidType. Matching is performed using <a class="el" href="a00019.html#gac8f08df74d65c8454528824a667550ec" title="Compares the entry value with the string string and store the result in result. ">cbor_value_text_string_equals()</a>, so tagged strings will also match.</p>
<p>This function has a time complexity of O(n) where n is the number of elements in the map to be searched. In addition, this function is has O(n) memory requirement based on the number of nested containers (maps or arrays) found as elements of this map.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gae8bf13b3880863cf5c8a0bddf52426e6" title="Returns true if the iterator it contains a valid value. ">cbor_value_is_valid()</a>, <a class="el" href="a00019.html#gac8f08df74d65c8454528824a667550ec" title="Compares the entry value with the string string and store the result in result. ">cbor_value_text_string_equals()</a>, <a class="el" href="a00019.html#gae2ede5aacd59f04437c24ef8ca2f449a" title="Advances the CBOR value it by one element, skipping over containers. ">cbor_value_advance()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b805f0f440905a7ba4f93b3569bb97b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_skip_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances the CBOR value <em>it</em> until it no longer points to a tag. </p>
<p>If <em>it</em> is already not pointing to a tag, then this function returns it unchanged.</p>
<p>This function does not run in constant time: it will run on O(n) for n being the number of tags. It does use constant memory (O(1) memory requirements).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gac0701f791608589ddfff0bdb8acee7b4" title="Advances the CBOR value it by one fixed-size position. ">cbor_value_advance_fixed()</a>, <a class="el" href="a00019.html#gae2ede5aacd59f04437c24ef8ca2f449a" title="Advances the CBOR value it by one element, skipping over containers. ">cbor_value_advance()</a> </dd></dl>

<p>Referenced by <a class="el" href="a00019.html#gaf145f4513ce734265d0128429cc4d5bd">cbor_value_map_find_value()</a>, and <a class="el" href="a00019.html#gac8f08df74d65c8454528824a667550ec">cbor_value_text_string_equals()</a>.</p>

</div>
</div>
<a class="anchor" id="gac8f08df74d65c8454528824a667550ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_text_string_equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the entry <em>value</em> with the string <em>string</em> and store the result in <em>result</em>. </p>
<p>If the value is different from <em>string</em> <em>result</em> will contain <code>false</code>.</p>
<p>The entry at <em>value</em> may be a tagged string. If <em>is</em> not a string or a tagged string, the comparison result will be false.</p>
<p>CBOR requires text strings to be encoded in UTF-8, but this function does not validate either the strings in the stream or the string <em>string</em> to be matched. Moreover, comparison is done on strict codepoint comparison, without any Unicode normalization.</p>
<p>This function may not run in constant time (it will run in O(n) time on the number of chunks). It requires constant memory (O(1)).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga2b805f0f440905a7ba4f93b3569bb97b" title="Advances the CBOR value it until it no longer points to a tag. ">cbor_value_skip_tag()</a>, <a class="el" href="a00019.html#ga02ec0b5c8346f407cf5def566ddcf5ae" title="Copies the string pointed by value into the buffer provided at buffer of buflen bytes. ">cbor_value_copy_text_string()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7636f480757b302845ee38227f15cef1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a full validation controlled by the <em>flags</em> options of the CBOR stream pointed by <em>it</em> and returns the error it found. </p>
<p>If no error was found, it returns CborNoError and the application can iterate over the items with certainty that no other errors will appear during parsing.</p>
<p>If <em>flags</em> is CborValidateBasic, the result should be the same as <a class="el" href="a00019.html#ga19b60bc2cff3d3ffcc81adbcad09fd58" title="Performs a basic validation of the CBOR stream pointed by it and returns the error it found...">cbor_value_validate_basic()</a>.</p>
<p>This function has the same timing and memory requirements as <a class="el" href="a00019.html#gae2ede5aacd59f04437c24ef8ca2f449a" title="Advances the CBOR value it by one element, skipping over containers. ">cbor_value_advance()</a> and <a class="el" href="a00019.html#ga19b60bc2cff3d3ffcc81adbcad09fd58" title="Performs a basic validation of the CBOR stream pointed by it and returns the error it found...">cbor_value_validate_basic()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#gac7df91cad1cba43d5d0103284fc390fc" title="The CborValidationFlags enum contains flags that control the validation of a CBOR stream...">CborValidationFlags</a>, <a class="el" href="a00019.html#ga19b60bc2cff3d3ffcc81adbcad09fd58" title="Performs a basic validation of the CBOR stream pointed by it and returns the error it found...">cbor_value_validate_basic()</a>, <a class="el" href="a00019.html#gae2ede5aacd59f04437c24ef8ca2f449a" title="Advances the CBOR value it by one element, skipping over containers. ">cbor_value_advance()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga19b60bc2cff3d3ffcc81adbcad09fd58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ga76e9c9acc63dd940da4ab7e91309f7b5">CborError</a> cbor_value_validate_basic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html">CborValue</a> *&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a basic validation of the CBOR stream pointed by <em>it</em> and returns the error it found. </p>
<p>If no error was found, it returns CborNoError and the application can iterate over the items with certainty that no other errors will appear during parsing.</p>
<p>A basic validation checks for:  </p>
<ul>
<li>absence of undefined additional information bytes; </li>
<li>well-formedness of all numbers, lengths, and simple values; </li>
<li>string contents match reported sizes; </li>
<li>arrays and maps contain the number of elements they are reported to have; </li>
</ul>
<p>For further checks, see <a class="el" href="a00019.html#ga7636f480757b302845ee38227f15cef1" title="Performs a full validation controlled by the flags options of the CBOR stream pointed by it and retur...">cbor_value_validate()</a>.</p>
<p>This function has the same timing and memory requirements as <a class="el" href="a00019.html#gae2ede5aacd59f04437c24ef8ca2f449a" title="Advances the CBOR value it by one element, skipping over containers. ">cbor_value_advance()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00019.html#ga7636f480757b302845ee38227f15cef1" title="Performs a full validation controlled by the flags options of the CBOR stream pointed by it and retur...">cbor_value_validate()</a>, <a class="el" href="a00019.html#gae2ede5aacd59f04437c24ef8ca2f449a" title="Advances the CBOR value it by one element, skipping over containers. ">cbor_value_advance()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
